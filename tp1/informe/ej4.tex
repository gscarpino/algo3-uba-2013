\section{Problema 4: Puzzle de casilleros}

\subsection{Introducci\'on}

\quad Para este tipo de problemas, se suele usar la t\'ecnica de \textit{backtracking}. No se conocen algoritmos polinomiales para resolver el problema. Tambi\'en se podr\'ia resolver con fuerza bruta pero la ventaja de esta t\'ecnica es que se busca armar e ir probando posibles soluciones. A medida de que se van construyendo, se puede determinar ciertos casos que no son posible soluci\'on, por lo que no se intentar\'ia resolver el problema en esos casos evitando ejecuciones innecesarias. En el peor caso, \textit{backtracking} es igual a intentar resolverlo por fuerza bruta.
\quad Se nos pide encontrar, si existe, alguno de los menores subconjuntos de piezas de tal forma que cubran todo el tablero. Donde cada casillero del tablero es de color negro o blanco, y cada pieza de forma rectangular, posee casilleros de los mismos colores. La pieza para poder ubicarse en cierta posici\'on del tablero tiene que coincidir exactamente en el tablero y se la puede rotar. 

\subsection{Desarrollo}

\quad Este ejercicio contiene varios problemas. Para empezar, nos encontramos con el requerimiento de dado un conjunto armar todos los subconjuntos posibles. Se conoce como \textit{power set}. La complejidad de este problema es exponencial, no se conocen algoritmos polinomiales hasta el momento.

\quad La primera implementaci\'on del problema de power set consist\'ia en usar una m\'ascara de bits para determinar si un elemento estaba presente o no en un conjunto. Se recorr\'ian los n\'umeros desde el 1 hasta $ 2^{ \vert piezas\vert} $ formando as\'i todas las posibles combinaciones de subconjuntos. Era simple pero ten\'ia el problema de que pod\'ia producir overflow en arquitecturas donde $\vert piezas\vert} $ sea mayor a la cantidad m\'axima de bits para alg\'un registro que sea utilizado como contador del procesador. Ej: con 40 piezas y un procesador de 32 bits.

\quad Por lo tanto, decidimos implementar este problema mediante la recursi\'on...

\quad
 
\quad

\quad Para resolver el problema principal, lo que hicimos fue ir probando cada uno de los subconjuntos con tama\~no desde 1 hasta la cantidad de piezas. Como punto de corte razonable, es haber encontrado alg\'un subconjunto como soluci\'on.

\quad Para determinar si cierto subconjunto de piezas es soluci\'on, primero determinamos una poda. Esta consiste en que, al buscar una soluci\'on \'optima, el subconjunto de piezas deb\'ia de cubrir exactamente el tablero. Si la superficie de las fichas era menor al del tablero, entonces no era soluci\'on. En cambio, si era mayor, podr\'ia ser soluci\'on, pero si lo era, no era \'optima porque sobraba alguna pieza. 

\quad Luego implementamos una funci\'on recursiva en la cual para cada ficha se buscaba sus posibles posiciones en el tablero. Para cada posici\'on, se creaba una instancia del tablero en la cual se la ubicaba ah\'i. Luego se llamaba devuelta a la funci\'on con ese tablero y sin esa pieza.

\quad El caso base de la funci\'on es cuando no quedan m\'as piezas para ubicar. Entonces se fija en el tablero si est\'a completamente cubierto, en caso afirmativo, se encontr\'o una soluci\'on al problema.

\quad La funci\'on tiene en cuenta las rotaciones de las piezas. Por lo que si no se encontr\'on soluci\'on, se rota la pieza. Si es id\'entica a la original, se corta esa rama. Caso contrario, se busca todas las posibles posiciones para esa pieza rotada, y se repite lo anterior.

\quad Una vez que se encuentra soluci\'on, si existe, se devuelve el vector con la informaci\'on de las piezas colocadas en el tablero. \'Este vector, lo maneja la clase \textit{Tablero} que hicimos, al cual agrega una pieza cada vez que es posible ubicarla en el tablero.

\quad En todo momento del desarrollo tuvimos que tener en cuenta generar todas las podas posibles para evitar ejecuciones innecesarias debido al tipo de problema.

\quad Creamos las clases \textit{Tablero} y \textit{Pieza} para que cada se encargue de las funciones que les competen propiamente a dicha abstracci\'on. 

\quad En la clase \textit{Tablero}, podemos crear un tablero con el tama\~no deseado, obtener las posibles posiciones de una pieza, si encaja la pieza en cierta posici\'on, si est\'a completo o no. Si cierto conjutno de piezas puede llegar a cubrir todo el tablero, obtener las piezas ubicadas, etc.

\quad En la clase \textit{Pieza}, podemos crear una pieza de cierto tama\~no, rotarla, etc.

\quad Utilizamos top-down y clases porque nos pareci\'o la mejor forma de organizar el programa para resolver el ejercicio. Haciendo m\'as prolijo el c\'odigo y \textit{tirar} los problemas del tablero se encarga su clase y el de la pieza el de ella misma.



\subsubsection{Correctitud}

\quad En cuanto la problema de la generaci\'on de todos los subconjuntos posibles de un conjunto, utilizamos un m\'etodo que dada la representaci\'on binaria de un n\'umero los elementos presentes en un conjunto son aquellos donde la posici\'on es igual al id del elemento y el bit est\'a en 1, es decir, es un elemento presente. Como se recorre desde el valor 1 hasta $ 2^{n} $ (n es cantidad de elementos), se recorre todas las posibles  combinaciones de elementos presentes y no presentes. Si bien esta forma sigue siendo un algoritmo exponencial, creemos que es m\'as eficiente que haber hecho una funci\'on recursiva que genere todos estos conjuntos.

\subsubsection{An\'alisis de complejidad}

Las funciones que utlizamos del tablero son:

\begin{itemize}

\item \textbf{getColor:} dada una posici\'on del tablero, devuelve el color, negro o blanco. Tiene un costo O(1) debido a que solo tiene que devolver un valor accediendo a una posici\'on de una matriz.

\item \textbf{posiblesPosiciones:} recorre todo el tablero, fij\'andose en cada posici\'on, si es posible ubicar la pieza ah\'i. Para esto llama a la funci\'on encaja. Guarda en un vector resultado las posiciones posibles de ubicar la pieza. La complejidad termina siendo la cantidad de posiciones del tablero (filas por columnas) iteraciones de la funci\'on encaja: O(filas * columnas * filasPieza * columnasPieza)

\item \textbf{encaja:} dada una pieza y una posici\'on, devuelve verdadero si es posible ubicar esa pieza en la posici\'on pasada por par\'ametro. Para esto, recorre toda la superficie de la pieza, por lo que cuesta O(filasPieza * columnasPieza)

\item \textbf{ocupado:} dada una posici\'on, devuelve si ya está ocupada por una pieza o no. Se tiene que acceder a una matriz, por lo que cuesta O(1).

\item \textbf{completo:} determina si el tablero est\'a totalmente cubierto por piezas. Para ello, tiene que recorrer todas las posiciones y llamar a la funci\'on ocupado. Tiene coste O(filas * columnas)

\item \textbf{ubicarFicha:} dada una pieza y una posici\'on modifica la instancia de tablero, seteando las posiciones correspondientes para considerarlas ocupadas. Adema\'a, guarda en un vector el id de la pieza, el grado de rotaci\'on de la misma, y la posici\'on del extremo superior izquierdo. Tiene un costo O(filasPieza * columnasPieza)

\item \textbf{obtenerPiezas:} la clase tablero guarda un vector con las piezas ubicadas en el mismo. Esta funci\'on devuelve una copia de ese vector. Tiene costo O(n) donde n es la cantidad de piezas.

\item \textbf{cubreTodo:} es una funci\'on para podar casos no posibles de ser soluci\'on como se explic\'o anteriormente. Calcula la superficie del tablero. Recorre todas las piezas, restando a la superficie del tablero la superficie de la pieza. Para cubrirlo exactamente tiene que quedar en 0. Caso contrario, se poda. Tiene un costo de O(n) donde n es la cantidad de piezas.

\end{itemize}

\subsection{Conclusiones}

\quad Considerando posibles mejoras ser\'ia que en vez de buscar \textit{linealmente} cual es la menor cantidad de piezas necesarias, se podr\'ia utilizar una busqueda binaria. Con linealmente nos referimos en el sentido de que probamos con una pieza, luego dos, y así sucesivamente hasta probar con todas las piezas. En cambio, con b\'usqueda lineal, se prueba con la mitad de piezas, si es soluci\'on, entonces existe una soluci\'on menor o igual a esa. Por lo que se busca una nueva soluci\'on entre la 1era mitad en cantidad de piezas. Sino, entonces era necesario m\'as piezas y se busca en la 2da mitad en cantidad de piezas.

\quad Hay que tener en cuenta que al ser un problema que no se resuelve polinomialmente, intentar resolver con un valor grande en cantidad de piezas puede demorar demasiado en comparaci\'on si se hubiese hecho b\'usqueda lineal. Si se pudiera hacer un estudio sobre las piezas y el tablero y se conociera una estad\'istica sobre la entrada del problema, se podr\'ia determinar casos donde conviene utlizar uno u otro.

\quad Con este problema, pudimos notar la importancia de determinar buenas podas o puntos de corte para tratar de realizar un backtracking eficiente. De esta forma, se puede llegar a resolver problemas dif\'iciles much\'isimo m\'as eficiente que si se hubiese realizado fuerza bruta.