\section{Problema 3: La caja en el plano}

\subsection{Introducci\'on}

\indent En este caso, el problema que se nos presentó para resolver fue el siguiente:\\
\indent Se tienen $n$ puntos en el plano con coordenadas enteras y se tiene adem\'as una caja, representada por un rect\'angulo de dimensiones dada. La caja puede ubicarse en cualquier lugar del plano, pero no puede rotarse, es decir, la base de la caja debe quedar paralela al eje $x$ y la altura de la caja debe quedar paralela al eje $y$. Un punto sobre un borde de la caja se considera dentro de la misma. Se desea ubicar la caja de manera tal que la cantidad de puntos que queden dentro de la caja sea m\'axima. El algoritmo que resuelva este problema debe hacerlo con una complejidad de a lo sumo \textbf{O}($n^{3}$).\\
\indent Es oportuno realizar alguna aclaraciones. En primer lugar, que el problema siempre tiene soluci\'on \'optima, es decir que siempre habr\'a una ubicaci\'on de la caja que cubra mayor o igual cantidad de puntos que todas las dem\'as. En segundo lugar, que la soluci\'on \'optima no siempre es \'unica. \\
\indent A continuaci\'on se provee un ejemplo de una posible instancia del problema con una posible soluci\'on y que adem\'as sirve para mostrar las aclaraciones hechas anteriormente:\\


							%DIBUJITO


\indent Para resolver este problema hemos asumido que por lo menos se tiene alg\'un punto en el plano (es decir que $k>0$) y que adem\'as los puntos que se proveen por entrada no est\'an repetidos.\\

\subsection{Desarrollo}


\indent Dado el problema a resolver, la primera noci\'on que se extrajo al momento de analizarlo fue el hecho de que siempre existe una soluci\'on \'optima, aunque no siempre es \'unica.\\
\indent Una primera aproximaci\'on intuitiva para la resoluci\'on consisti\'o en ir posicionando la esquina inferior izquierda de la caja en todos los lugares posibles de un \'area acotada por cuatro puntos, cada uno el m\'as extremo hacia la izquierda, la derecha, arriba o abajo. Si bien parece l\'ogico encontrar la soluci\'on deseada de esta manera, el algoritmo ser\'ia muy complejo (y en particular la complejidad estar\'ia condicionada por la lejan\'ia entre los puntos extremos), por lo que resultaba necesario acotar de alguna manera las posibles posiciones donde se evaluar\'ia la esquina inferior izquierda de la caja.\\
\indent Una segunda aproximaci\'on consisti\'o en ir probando cada punto en los cuatro v\'ertices de la caja y evaluar cu\'antos de los dem\'as puntos entrar\'ian en ella. Sin embargo, esta idea no result\'o ser fruct\'ifera: solamente est\'abamos evaluando potenciales soluciones que cumpl\'ian con tener por lo menos un punto en el v\'ertice y no es cierto que siempre existe una soluci\'on \'optima que tenga por lo menos un punto en el v\'ertice.\\
\indent Luego de analizar m\'as detenidamente el contexto del problema, se comprendi\'o que a partir de un posicionamiento de la esquina inferior izquierda de la caja con la condici\'on de que por lo menos un punto quedara cubierto por ella, uno podr\'ia encontrar otro posicionamiento que cumpliera que por lo menos un punto cubierto por ella se encuentre en el borde inferior de la caja y otro en el borde izquierdo de la caja (puede darse el caso que sean el mismo punto, si es así el punto estar\'ia ubicado en el v\'ertice inferior izquierdo de la caja) y que la cantidad de puntos dentro de la caja de este posicionamiento es mayor o igual que la cantidad del primer posicionamiento.\\
 								
 								%DIBUJITO

\indent  De aqu\'i se extrae que siempre hay por lo menos una solución \'optima que cumpla con estos criterios, puesto que la soluci\'on \'optima debe cubrir por lo menos un punto. En particular, esa soluci\'on \'optima cumple con que el componente $x$ de su esquina inferior izquierda se corresponde con la coordenada $x$ de alguno de los puntos que se tienen en el plano y que el componente $y$ de su esquina inferior izquierda se corresponde con la coordenada $y$ de alguno de los puntos que se tienen en el plano (y que no necesariamente son el mismo punto).Una demostraci\'on de todo esto se puede encontrar en la secci\'on de Correctitud de este problema.\\
\indent De esta manera hemos reducido el conjunto de posibles soluciones a uno m\'as pequeño y que sabemos con seguridad que contiene una soluci\'on \'optima.\\ 
\indent Luego, las potenciales soluciones son las esquinas inferiores izquierdas que cumplen que su coordenada $x$ se corresponde con la componente $x$ de alguno de los puntos en el plano y que su coordenada $y$ se corresponde con la componente $y$ de alguno de los puntos en el plano.\\
\indent As\'i, hay a lo sumo $n^{2}$ candidatos a soluci\'on a analizar que se obtienen de combinar la coordenada $x$ de cada punto con las coordenadas $y$ de todos los puntos. En particular, nuestro algoritmo recorre estos candidatos a soluci\'on y devuelve el candidato que m\'as puntos cubra, siendo as\'i una soluci\'on \'optima.\\

\subsection{Algoritmo} 

\indent Queremos hacer un par de aclaraciones: $n$, $b$ y $h$ son de tipo $int$ y representan la cantidad de puntos, la base de la caja y la altura de la caja respectivamente. A su vez, puntosX contiene en la posici\'on $i$ la coordenada $x$ del i-\'esimo punto de la entrada. An\'alogamente, puntosY contiene en la posici\'on $i$ la coordenada $y$ del i-\'esimo punto de la entrada. Por lo tanto, la longitud de ambos vectores es $n$, la cantidad de puntos en el plano.\\
\indent El algoritmo recorre los candidatos a soluci\'on que cumplen que su coordenada $x$ coincide con la de alg\'un punto del sistema y que su coordenada $y$ coincide con la de alg\'un punto del sistema (que puede no ser el mismo que el de la coordenada $x$).\\
\indent Esto se basa en el hecho de que en dicho conjunto de puntos seguro existe por lo menos una soluci\'on \'optima. Se provee la demostraci\'on de esta afirmaci\'on en la secci\'on Correctitud de este problema.\\


\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{resolver}(n, b, h, vector<int> puntosX, vector<int> puntosY)$}
\li int $cant \gets 0$
\li int $m \gets 0$
\li int $resx \gets puntosX[0]$
\li int $resy \gets puntosY[0]$
\li \For int $i$ desde 0 hasta n \Do
\li		\For int $j$ desde 0 hasta n \Do
\li 		$m \gets $ cuantosEntran(n, b, h, puntosX[i], puntosY[j], puntosX, puntosY)
\li 		\If $(cant<m)$ 
\li				\Then   $cant \gets m$
\li 					$resx \gets puntosX[i]$
\li 					$resy \gets puntosY[j]$
				\End
			\End
		\End
	\End
\li \Return $cant$ , $resx$, $resy$

\End
\end{codebox}
\end{algorithm}


\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{cuantosEntran}(n, b, h, x, y, vector<int> puntosX, vector<int> puntosY)$}
\li int $cant \gets 0$
\li \For int $i$ desde 0 hasta n \Do
\li 	\If ($(x \leq puntosX[i] \leq x+b)$  $AND$  $(y \leq puntosY[i] \leq x+h)$) \Do
\li 		$cant$ ++		
 		\End
 	\End	
\li \Return $cant $
\End
\end{codebox}
\end{algorithm}

\subsubsection{Correctitud}

\subsubsection{Análisis de Complejidad}

\indent Analicemos en primer lugar la complejidad de $cuantosEntran$. Asignarle un valor a la variable $int$ $cant$ cuesta tiempo constante, es decir \textbf{O}(1). A su vez, evaluar la condición del If también cuesta tiempo constante.Esto es porque realizar la comparaci\'on de $int$'s es constante y, de acuerdo a la documentaci\'on de C++, obtener un elemento de un vector mediante el operador [] tambi\'en lo es. Por lo tanto, evaluar la condición del If es \textbf{O}(1). Luego, se entre o no al cuerpo del If, en cada iteraci\'on del ciclo se ejecuta algo de costo constante. Como el ciclo se itera $n$ veces (siendo $n$ la cantidad de puntos que hay en el plano), el algoritmo $cuantosEntran$ tiene un costo de\\
\begin{center}
\textbf{O}(1 + n*1)
\end{center}\\

con lo cual tiene una complejidad temporal \textbf{O}(n), es decir lineal en la cantidad de puntos.\\


\indent Analicemos ahora $resolver$. Las primeras cuatro asignaciones se realizan en tiempo constante (incluso las que obtienen un valor del vector con el operador [ ]), es decir en \textbf{O}(1).\\
\indent Veamos que ocurre en el cuerpo del segundo For. Se ejecuta $cuantosEntran$, que ya sabemos que lo hace en tiempo lineal, y lo que devuelve se lo asigna a una variable (en tiempo constante). Luego se hace una comparaci\'on en \textbf{O}(1).\\
\indent Ahora bien, si no entra al cuerpo del If no se hace nada más y se pasa a la pr\'oxima iteraci\'on. En este caso el costo de la iteración fue de \textbf{O}(n+2), con lo cual tiene una complejidad temporal de \textbf{O}(n).\\
\indent En cambio, si entra al cuerpo del If, se realizan tres asignaciones, todas en tiempo constante. Luego lo que está adentro del cuerpo del If tiene un costo de \textbf{O}(1). Es decir que en este caso también una iteraci\'on cuesta \textbf{O}(n).\\
\indent De aqu\'i se extrae que lo que ocurre en cada iteraci\'on de este For tiene un costo lineal. Como este For se ejecuta $n$ veces, su complejidad temporal será \textbf{O}($n^2$).\\
\indent Entonces, el primer For ejecuta en cada iteración algo con un costo cuadrático. Como se itera $n$ veces se obtiene que el costo de este For es \textbf{O}($n^3$). Es decir que el algoritmo cuesta \\
\begin{center}
\textbf{O}(1+1+1+ n^3)
\end{center}\\

con lo cual tiene un complejidad temporal de \textbf{O}($n^3$), es decir c\'ubica en la cantidad de puntos, cumpliendo entonces con la cota que se nos exigía en el enunciado del problema.\\


\subsection{Pruebas}

\subsection{Conclusiones}


