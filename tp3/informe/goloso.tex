\section{Heurística Constructiva Golosa}

\subsection{Algoritmo}

\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{maximoImpactoGoloso}(Grafo$ g$, Grafo$ h$, double $ porcentaje$)$}
\li
\li	vector$<$unsigned int$>$ res(n+1)
\li res[0] \gets 0
\li
\li vector$<$unsigned int$>$ coloreo(n,1) // todos sus elementos valen 1
\li vector$<$unsigned int$>$ colores(g.gradoMaximo()+1) 
\li
\li \For i desde 0 hasta la cantidad de colores a usar \Do

\li 		colores[i] = i+1
 	\End

\li
\li vector$<$bool$>$ modificados(n,false) //todos sus elementos valen false
\li unsigned int nodo
\li
\li \While $coloreo$ no sea un coloreo legal de g \Do
\li
\li 	nodo \gets $siguienteModificable(G,H,coloreo,modificados,porcentaje)$
\li
\li     \For c desde 1 hasta la cantidad de colores a usar \Do
\li 				  	
\li  			\If pintar a $nodo$ de color c es legal \Do
\li 					coloreo[nodo] \gets $colores[c]$
\li 					salir del for
				\End
\li
		\End
\li 	modificados[nodo] \gets $true$
\li
	\End
\li
\li res[0] \gets $h.impacto(coloreo)$
\li
\li \For i desde 1 hasta n \Do
\li 	res[i+1]=coloreo[i]
\li \End
\li
\li return res
	
\End
\end{codebox}
\end{algorithm}


\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{siguienteModificable}(Grafo$ g$, Grafo$ h$, vector<unsigned$ int$>$ coloreo, $	vector<bool> $ modificados$, double $ porcentaje$)$}
\li
\li 	vector$<$ tupla$<$unsigned int, unsigned int $> >$ posibles
\li     \For i desde 1 hasta n \Do
\li  		\If el nodo i no fue modificado y tiene vecinos \Do
\li				agregar a posibles la tupla $<$impactoNodo(i,h, coloreo), i$>$
			\End
		\End
\li 
\li 	ordenar posibles de menor a mayor
\li 	
\li 	\For i desde 0 hasta el tamaño de posibles -1 \Do
\li
\li 		\For j desde i+1 hasta el tamaño de posibles \Do
\li
\li 			\If posibles[i].first == posibles[j].first \Do
\li 				
\li 					\If grado de posibles[i].second en g$<$ grado de posibles[j].second en g\Do
\li 						swap(posibles[i], posibles[j])
						\End
\li						\Else 
\li 						\If grado de posibles[i].second en g== grado de posibles[j].second en g \Do
\li 							\If grado de posibles[i].second en h $<$ grado de posibles[j].second en h \Do
\li										swap(posibles[i], posible[j])
								\End
							\End
						\End
				\End
			\End
		\End
\li
\li
\li res \gets $elemento elegido al azar de $ 
\li          alguno de los primeros (tamaño de posibles*porcentaje) elementos de posibles
\li
\li return posibles[res].second
\li
\End
\end{codebox}
\end{algorithm}



\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{impactoNodo}($unsigned int $ nodo$$, Grafo$ h$, vector<unsigned$ int$>$ coloreo$)$}
\li
\li unsigned int res \gets 0
\li vector$<$unsigned int$>$ vecinos \gets $vecinos del nodo $nodo$ en h$
\li
\li \For i desde 0 hasta la cantidad de vecinos de $nodo$ en h \Do
\li
\li 	\If coloreo[nodo]==coloreo[vecinos[i]] \Do
\li 		res++
		\End
	\End
\li
\li return res
\End
\end{codebox}
\end{algorithm}



\subsection{Análisis de complejidad}

\indent Comencemos analizando la complejidad de la función impactoNodo.\\
\indent Esta función mira para un nodo el impacto que aporta en H, comparando su color con el de sus vecinos. Dicho nodo tiene en H a lo sumo n-1 vecinos. Luego, impactoNodo cuesta O(n).

\indent Analicemos ahora siguienteModificable. Al inicio comienza iterando sobre la cantidad de nodos de H y si dicho nodo no fue modificado o si no tiene vecinos, se calcula el impacto de cada nodo y se lo agrega a un vector de nodos candidatos a ser modificados.En el peor caso, todos los nodos están sin modificar y tienen vecinos,por lo tanto esto cuesta O($n^{2}$).\\
\indent Luego, se ordena de manera creciente el vector de candidatos de acuerdo al impacto de cada nodo.En el peor caso dicho vector tiene n elementos, pues todos los nodos son modificables y ordenarlos cuesta entonces O(n*log(n)).\\
\indent Luego, se itera sobre la cantidad de elementos de ese vector, esta vez para desempatar los nodos. En el peor caso todos los nodos empatan en el impacto que generan. Desempatarlos a todos cuesta en el peor caso O($n^{2}$) , que el caso en el que se invirtió el orden del vector por desempates.\\
\indent A continuación se elige pseudoaleatoriamente en O(1) uno de los primeros elementos del vector.\\
\indent Pasando en limpio, siguienteModificable cuesta O($n^2$ + n*log(n)+ $n^2$), que es O($n^{2}$).\\

\indent Ahora analicemos maximoImpactoGoloso.\\
\indent Al principio realiza unas cuantas operaciones en O(n). De estas es destacable la creación de un vector de tamaño igual al grado del nodo con grado máximo de G, que refiere a la cantidad de colores a usar. Pero el grado máximo de cada nodo es a lo sumo n-1. Luego crear ese vector cuesta O(n).\\
\indent Luego, se ejecuta un while que a lo sumo itera n veces. Esto es porque en el peor caso tuve que pintar todos los nodos de distinto color hasta obtener un coloreo válido.\\
\inden Dentro de ese while está implícito el chequeo de si el coloreo es válido, que cuesta O(n+m), donde vamos a acotar a m como el máximo entre las aristas de G y de H. Se ejecuta siguienteModificable y se itera luego en la cantidad de colores, costando cada iteración en la cantidad de colores O(n) que es lo que cuesta ver si pintar un nodo de ese color es no coincide con el color de uno de los vecinos de ese nodo, que como mencionamos antes pueden ser n-1.\\
\indent Luego, lo de adentro del while cuesta O(n+m+ $n^{2}$) y el costo total del while es de O(n(n+m +$n^{2}$)), que es O(n*(n+m)+ $n^{3}$).\\
\indent Luego de iterar se calcula el impacto de dicho coloreo en O(n+m).\\
\indent Es decir que en total maximoImpactoGoloso cuesta O(n+n*(n+m)+ $n^{3}$ + n+m).\\
\indent Por lo tanto, maximoImpactoGoloso cuesta O(n*(n+m)+ $n^{3}$).\\
 
\subsection{Experimentación y Resultados}
