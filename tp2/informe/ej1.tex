\section{Problema 1: Mutaciones bacteriales}
 
\subsection{Introducci\'on}

Nos encontramos estudiando el proceso de mutaciones de un conjunto de bacterias, el cual puede describirse de la siguiente manera:
una bacteria nace perteneciendo a una cepa determinada;
durante el transcurso de su vida, la bacteria puede mutar de una cepa a otra hasta que en
algun momento alcanza una cepa terminal desde la cual yo no puede seguir mutando. 
Este paso entre cepas define una cadena de mutaciones.

Se sabe que una bacteria en una determinada cepa no puede mutar directamente a cualquier otra cepa y que, ademas, las mutaciones entre cepas estan regidas por probabilidades.
Notemos que en este escenario podr\'ia suceder el caso de una cadena infinita de mutaciones.

El problema presentado consiste en identificar la cadena de mutaciones m\'as larga que una bacteria podr\'ia seguir dentro de un conjunto de cepas, dado que se conocen las probabilidades de mutaci\'on entre las cepas. Adem\'as, se desea identificar si dicho conjunto de cepas puede llevar que una bacteria mute infinitamente (aunque para este caso no necesitamos determinar la cadena de mutaciones).


\subsection{Desarrollo}


Comenzamos modelando el escenario del problema como un grafo dirigido donde cada nodo representa una cepa y cada arista, la mutación de una cepa a otra.
A partir de aqui, podemos traducir el problema original en una problema sobre grafos: encontrar la secuencia mas larga de mutaciones equivale a hallar el camino simple mas largo dentro del digrafo propuesto. En principio, este camino puede partir de cualquier nodo; más adelante veremos una forma de salvar este detalle.

Nos enfocamos, a partir de ahora, al problema de hallar el camino simple m\'as largo dentro de un digrafo. 
El caso que nos interesa es el de digrafos aciclicos (DAG), por lo que al referirnos a digrafos estaremos suponiendo que estos son DAGs.

Comencemos pensando en como encontrar el camino simple mas largo con origen en un nodo en particular. 
Supongamos que partimos del nodo A. El camino m\'as largo que podemos hallar desde A a cualquier otro nodo en el DAG necesariamente
debe pasar por alguno de los nodos alcanzables directamente desde A.
Pero entonces, el camino mas largo a partir de A debe ser el camino mas largo a partir de uno de sus nodos alcanzable, mas A.
Es decir, la soluci\'on se basa en subsoluciones a subproblemas de igual tipo pero menor tamaño (lo que vale pues estamos trabajando sobre un DAG).
Esto nos lleva a pensar en aplicar la tecnica de programacion dinamica en la resolucion del problema.

Definamos, entonces, $F(v)$ como la longitud del camino simple más largo que comienza en el nodo $v$.

$$F(v)= \max_{u\;\in\;N_{o}(v)} \{F(u)\; + \; 1\}$$

donde $N_{o}(v)$ es la vecindad de salida del nodo v (el conjunto de nodos alcanzables desde v). 
En esta definici\'on consideramos que el m\'aximo de un conjunto vac\'io es 0.

En lugar de proponer una funcion recursiva (inmediata a partir de la definicion de F), veamos llegar a un
algoritmo itereativo: al calcular la solucion para un nodo i, solo necesitamos tener las subsoluciones de sus nodos "`hijos"'.
Por lo tanto, iremos calculando las F(i) siguiendo un ordenamiento topologico lineal inverso. 
Un ordenamiento topologico de los nodos de un digrafo es aquel en el que ningun nodo hijo aparece antes que su padre (los DAG siempre tiene un orden topologico). Debemos notar que el ordenamiento topológico de un grafo no siempre es único.

Entonces, mantendremos un arreglo de longitudes, sea L, donde L[i] representa la longitud del camino simple mas largo que nace en el nodo i, y lo llenaremos siguiendo el ordenamiento previamente explicado. Ademas, mantendremos un arreglo S donde S[i] es es el nodo hijo de i que se eligio como subsolucion optima. De esta manera, al terminar el llenado de los arreglos podremos reconstuir el camino simple de mayor longitud que parte de cada nodo.

Para calcular el ordenamiento topologico lineal, seguimos la idea planteadas en [Cormen] y utilizamos el algoritmo de recorrido \tetbf{DFS} (Depth First Search o búsqueda en profundidad). El algoritmo se modifico levemente, de manera de que guarde el orden a medida que va cerrando los nodos (en lugar de armar el ordenamiento una vez que DFS termina y marca los timestamp de finalizacion de cada nodo), y chequee que al visitar un nodo, si este esta siendo explorado (su color es GRIS), entonces finalice indicando que se encontr\'o un ciclo.
De esta forma, para decidimos si el digrafo es un DAG y armamos los datos necesarios para proceder con el algoritmo dinamico en un unico paso inicial. Cabe aclarar que un digrafo es DAG si y solo si puede encontrarse un ordenamiento topologico para sus nodos.  

Ahora volvamos al problema original. En primer lugar, si queremos hallar el camino simple mas largo, deberiamos ejecutar el algoritmo en cada nodo sin aristas entrantes. Ademas, el grafo armado por las relaciones entre las cepas puede ser disconexo. 
Para sortear estos detalles, a la hora de implementar el problema se tomó la decisión de agregar un nodo inicial. Este nodo dirige sus aristar a cada uno de los demás nodos del digrafo original, por lo que el digrafo resultante resulta ser conexo. Notemos que agregar este nodo no altera la solución del problema. Si en el grafo original no hay ciclos, como las aristas que se agregan solo van del nuevo nodo inicial al resto y nunca al reves, el grafo resultante tampo contendra ciclos. De igual manera se ve que si el grafo original contenia un cico, agregar el nodo artificial no eliminar\'a el o los ciclos preexistentes. 

La solucion final del problema, entonces, es calcular el camino simple mas largo que tiene como origen al nodo artificial: S[nodoArtifial], con distancia L[nodoArtifial].



\subsection{Algoritmo}

\indent En las funciones $ordenTopologico$ y $visitar$ consideramos a los nodos de la siguiente manera:\\
\indent Un nodo es BLANCO si todavía no se lo ha visitado. Si se lo visitó, pero todavía no se recorrió todas sus ramas, el nodo será GRIS. En cambio, cuando se recorrió todo la rama del nodo, éste será NEGRO.\\
\indent Antes de llamar a $ordenTopologico$ todos los nodos están en BLANCO. \\
\indent Como se puede observar, $ordenTopologico$ es un DFS modificado, en el sentido que a medida que el algoritmo recorre los nodos, los agrega en una lista manteniendo el orden topológico.\\


\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{ordenTopologico}(lista$ $nodosOrdenados)$}
\li \While existen nodos BLANCO \Do
\li	$n \gets$ seleccionar nodo BLANCO
\li	visitar(n, nodosOrdenados)

\End
\end{codebox}
\end{algorithm}


\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{visitar}(nodo$ $n$, $lista$ $nodosOrdenados)$}
\li \If n es GRIS \Do
\li 	 Terminar pues hay ciclo
\li \End
\li \If n es BLANCO \Do
\li 	marcar n GRIS
\li		\For cada hijo m de n \Do
\li			visitar(m)			
\li		\End
\li		marcar n NEGRO
\li 		insertar n al principio de $nodosOrdenados$
\li 		Terminar
\li \End

\End
\end{codebox}
\end{algorithm}
 


\begin{algorithm}[H]
\caption{} 
\begin{codebox}
\Procname{$\proc{caminoMaximo}(vector< int >$ camino )}
\li $n \gets \# nodos $
\li vector$<int>$ siguienteEnCamino(n)
\li vector$<int>$ orden(n)
\li vector$<int>$ dist(n)
\li ordenTopologico(orden)
\li \If no hay ciclo \Do
\li 	\For i desde n-1 hasta 1 \Do
\li		int v $\gets$ orden[i]
\li		dist[v] $\gets$ 0
\li 		siguienteEnCamino[v] $\gets$ 0
\li		\For cada hijo de v \Do
\li		  	\If dist[hijo] + 1 $>$ dist[v] \Do
\li				dist[v] $\gets$ dist[hijo]+ 1
\li				siguienteEnCamino[v] $\gets$ hijo
\li			\End
\li		\End
\li	\End
\li	int f $\gets$ 0
\li	\While siguienteEnCamino[i] distinto de 0 \Do
\li		i $\gets$ siguienteEnCamino[i]
\li		agregar i al final de $camino$
\li	\End
\li 	int maxDist $\gets$ dist[0]
\li 	\Return maxDist , camino	
\li \End
\li \Else \Do
\li \Return -1
\End

\end{codebox}
\end{algorithm}

\subsubsection{Correctitud} 



\subsubsection{An\'alisis de complejidad}
 
 

\subsection{Pruebas}



\subsection{Conclusiones}
